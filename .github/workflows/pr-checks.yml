name: PR Checks & Automation

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches: [main, develop]

jobs:
  # ==================================
  # PR Title & Description Validation
  # ==================================
  validate-pr:
    name: Validate PR Title & Description
    runs-on: ubuntu-latest

    steps:
      - name: Check PR title format
        uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            build
            ci
            chore
          requireScope: false
          subjectPattern: ^[A-Z].*$
          subjectPatternError: |
            The subject must start with an uppercase letter.
            Examples:
            - feat: Add user authentication
            - fix: Resolve video processing bug
            - docs: Update README with testing instructions

      - name: Check PR description
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            if (!pr.body || pr.body.length < 20) {
              core.setFailed('PR description is too short. Please provide a meaningful description.');
            }

  # ==================================
  # Auto-label PR
  # ==================================
  auto-label:
    name: Auto-label PR
    runs-on: ubuntu-latest

    steps:
      - name: Label based on changed files
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml

      - name: Label PR size
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const additions = pr.additions;
            const deletions = pr.deletions;
            const total = additions + deletions;

            let sizeLabel = '';
            if (total < 10) sizeLabel = 'size/XS';
            else if (total < 50) sizeLabel = 'size/S';
            else if (total < 200) sizeLabel = 'size/M';
            else if (total < 500) sizeLabel = 'size/L';
            else sizeLabel = 'size/XL';

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [sizeLabel]
            });

  # ==================================
  # Check for Breaking Changes
  # ==================================
  breaking-changes:
    name: Check for Breaking Changes
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for breaking changes in PR
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const title = pr.title.toLowerCase();
            const body = pr.body?.toLowerCase() || '';

            const hasBreakingChange =
              title.includes('breaking') ||
              title.includes('!:') ||
              body.includes('breaking change') ||
              body.includes('breaking-change');

            if (hasBreakingChange) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['breaking-change']
              });

              core.warning('âš ï¸ This PR contains breaking changes!');
            }

  # ==================================
  # Check for Test Coverage
  # ==================================
  coverage-check:
    name: Check Test Coverage Change
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run coverage on PR branch
        env:
          TESTING: 1
          FLASK_ENV: testing
        run: |
          pytest --cov=src --cov=app --cov-report=json --cov-report=term-missing
          mv coverage.json coverage-pr.json

      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.base_ref }}

      - name: Run coverage on base branch
        env:
          TESTING: 1
          FLASK_ENV: testing
        run: |
          pytest --cov=src --cov=app --cov-report=json
          mv coverage.json coverage-base.json
        continue-on-error: true

      - name: Compare coverage
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let prCoverage = 0;
            let baseCoverage = 0;

            try {
              const prData = JSON.parse(fs.readFileSync('coverage-pr.json', 'utf8'));
              prCoverage = prData.totals.percent_covered;
            } catch (e) {
              core.info('Could not read PR coverage');
            }

            try {
              const baseData = JSON.parse(fs.readFileSync('coverage-base.json', 'utf8'));
              baseCoverage = baseData.totals.percent_covered;
            } catch (e) {
              core.info('Could not read base coverage');
            }

            const diff = prCoverage - baseCoverage;
            const emoji = diff >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';

            const comment = `## ${emoji} Code Coverage Report

            - **PR Coverage**: ${prCoverage.toFixed(2)}%
            - **Base Coverage**: ${baseCoverage.toFixed(2)}%
            - **Difference**: ${diff >= 0 ? '+' : ''}${diff.toFixed(2)}%

            ${diff < 0 ? 'âš ï¸ Coverage decreased! Please add tests.' : 'âœ… Coverage maintained or improved!'}
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # ==================================
  # Check for TODOs
  # ==================================
  todo-check:
    name: Check for TODOs
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Find TODOs
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            try {
              const todos = execSync('grep -rn "TODO\\|FIXME\\|XXX\\|HACK" src/ || true').toString();

              if (todos) {
                const comment = `## ðŸ“ TODOs Found

                The following TODOs were found in the codebase:

                \`\`\`
                ${todos}
                \`\`\`

                Please address these before merging or create issues to track them.
                `;

                github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: comment
                });
              }
            } catch (e) {
              core.info('No TODOs found');
            }

  # ==================================
  # Check File Size
  # ==================================
  file-size-check:
    name: Check for Large Files
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for large files
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const largeFiles = files.filter(file => file.additions + file.deletions > 500);

            if (largeFiles.length > 0) {
              const fileList = largeFiles.map(f =>
                `- ${f.filename} (${f.additions + f.deletions} lines)`
              ).join('\n');

              const comment = `## âš ï¸ Large Files Detected

              The following files are quite large:

              ${fileList}

              Consider breaking them into smaller, more manageable pieces.
              `;

              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }

  # ==================================
  # Auto-assign Reviewers
  # ==================================
  auto-assign:
    name: Auto-assign Reviewers
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'

    steps:
      - name: Assign reviewers
        uses: actions/github-script@v7
        with:
          script: |
            // Auto-assign based on file changes
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            let reviewers = [];

            // Add logic to assign reviewers based on changed files
            const hasTestChanges = files.some(f => f.filename.startsWith('tests/'));
            const hasDocsChanges = files.some(f => f.filename.endsWith('.md'));
            const hasCIChanges = files.some(f => f.filename.startsWith('.github/'));

            if (hasTestChanges || hasCIChanges) {
              // Assign QA reviewer
              reviewers.push('speudoname');
            }

            if (reviewers.length > 0) {
              try {
                await github.rest.pulls.requestReviewers({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  reviewers: [...new Set(reviewers)]  // Remove duplicates
                });
              } catch (e) {
                core.info('Could not assign reviewers');
              }
            }
